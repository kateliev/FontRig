# SCRIPT: FR-UFO-REPL
# NOTE: A convenient and interactive way to play with 
# NOTE: Unified Font Object Files
# -----------------------------------------------------------
# (C) Vassil Kateliev, 2024         (http://www.kateliev.com)
#------------------------------------------------------------

# No warranties. By using this you agree
# that you use it at your own risk!

from __future__ import absolute_import, print_function, unicode_literals

__version__ = 1.00

# - Dependencies --------------------------------------------
import argparse
import datetime
import json
import os
import sys
import time
import ufoLib2

from collections import OrderedDict
from fontTools import designspaceLib

# -- String -------------------------------------------------
tool_name = 'FR-UFO-REPL'
tool_description = 'FontRig UFO REPL'
tool_description_long = 'A convenient and interactive way to play with Unified Font Object Files.\n Please run with Python -i script.py font.designspace'

# - OT Feature related functions and config ----------------------------
# --- Feature code
simple_fea = '# {com}\nfeature {tag} {{\n {body}\n}} {tag};'
simple_sub = '\tsub {glyph_in} by {glyph_out};'
injector_comment = '\n# NOTE: Injected arbitrary text substitutions follow'
fea_head='''# File:			OpenType Layout feature definitions
# Format: 		Adobe FDK for OpenType (AFDKO) version 2.5
# Generated by: {generator}
# Generated on: {time}
# Font name: 	{fontname}
'''

fea_lang = '''# Languagesystem definitions
languagesystem DFLT dflt; # Default default
languagesystem latn dflt; # Latin default
'''

# --- Configuration
# ---- Propmpts
sys.ps1='\x01\x1b[1;49;33m\x02>>>\x01\x1b[0m\x02 '  # bright yellow 
sys.ps2='\x01\x1b[1;49;31m\x02...\x01\x1b[0m\x02 '  # bright red

# --- String
liga_mark = ('_', ' underscore ')
replace_dict = {'0':'digit_zero',
				'1':'digit_one',
				'2':'digit_two',
				'3':'digit_three',
				'4':'digit_four',
				'5':'digit_five',
				'6':'digit_six',
				'7':'digit_seven',
				'8':'digit_eight',
				'9':'digit_nine'
				}

# ---- List of reserved words that we will escape with backslash
ignored_words = []
ignored_glyphs = ['.notdef', 'space', 'uni00A0', 'uni000A', 'period', 'CR']

# -- Path and file ------------------------------------------
ext_designspace = '.designspace'

# -- Classes ------------------------------------------------
class inspect_obj(object):
	def __init__(self, obj):
		self.object = obj
		self.contents = dir(obj)
		self.call, self.attrib = [], []
		self.dir = self.list_items()

		for item in self.contents:
			if callable(getattr(obj, item)):
				self.call.append(item)
			else:
				self.attrib.append(item)

		self.call_clean = [item for item in self.call if '_' not in item]
		self.attrib_clean = [item for item in self.attrib if '_' not in item]

	def get_attribs(self):
		return [(attrib, getattr(self.object, attrib)) for attrib in self.attrib_clean]

	def list_items(self):
		for item in self.contents:
			print('.{:30s}\t{:30s}'.format(item, str(type(getattr(self.object, item)))))

	def __eq__(self, other):
		self_attribs = self.get_attribs()
		other_attribs = other.get_attribs()

		if len(self_attribs) == len(other_attribs):
			for i in range(len(self_attribs)):
				print('Test: %s;\tAttrib: %s;\tValues: %s' %(self_attribs[i][1] == other_attribs[i][1], self_attribs[i][0], (self_attribs[i][1], other_attribs[i][1])))

# --- Functions ---------------------------------------------
def cls():
	os.system('cls' if os.name=='nt' else 'clear')

def chunk_slicer(process_list, chunk_size):
	for i in range(0, len(process_list), chunk_size):
		yield process_list[i:i + chunk_size]

def str_filter(string, sub_string, replace=''):
	return re.sub('(?i:{match}).*\\s||(?i:{match})'.format(match=str(sub_string)), str(replace), str(string)).strip()
	
def str_join(str_list, join_with=' ', replace_tuple=None, fallback='Regular'):
	if replace_tuple is not None:
		tmp_str_list = [str(item).replace(*replace_tuple).strip() for item in str_list]
	else:	
		tmp_str_list = [str(item).strip() for item in str_list]

	tmp_string = join_with.join(tmp_str_list).strip()
	
	if not len(tmp_string) and fallback is not None: return fallback
	return tmp_string

def strRepDict(stringItems, replacementDicionary):
	'''	Replaces every instance of [stringItems] according to [replacementDicionary]'''
	for key, value in replacementDicionary.items():
		stringItems = stringItems.replace(key, value)
	return stringItems

def str_process(string, ignore_liga_mark = True):
	if string[0] == liga_mark[0] and ignore_liga_mark: string = string [1:]	
	temp_string = liga_mark[1].join([' '.join(list(item)) for item in string.split(liga_mark[0])])
	return strRepDict(temp_string.strip(), replace_dict)

def list_filter(input_list, discard_list, check_index=None):
	if check_index is None:
		return [item for item in input_list if item not in discard_list]
	else:
		return [item for item in input_list if item[check_index] not in discard_list]

def subs_pairs_for_glyphname(glyphnames):
	# - Init
	glyph_subs_pairs = []

	# - Process
	for glyph_name in glyphnames:
		if glyph_name not in ignored_glyphs and not any([iw in glyph_name for iw in ignored_words]):
			subst_string = str_process(glyph_name)
			glyph_name = glyph_name if glyph_name not in special_words else '\\' + glyph_name
			
			addon_tuple = (subst_string, glyph_name)
			glyph_subs_pairs.append(addon_tuple)

	return glyph_subs_pairs

def subs_pairs_from_pairlist(pairlist, glyph_check_list):
	# - Init
	glyph_subs_pairs = []

	# - Process
	for subst_in, subst_out in pairlist:
		if subst_in not in ignored_glyphs and not any([iw in subst_in for iw in ignored_words]):
			if subst_out in glyph_check_list:
				addon_tuple = (str_process(subst_in, False), subst_out if subst_out not in special_words else '\\' + subst_out)
				glyph_subs_pairs.append(addon_tuple)

	return glyph_subs_pairs

def sort_pairs(pairlist, len_index, alpha_index):
	return sorted(pairlist, key=lambda i: (len(i[len_index]), i[alpha_index]))

def fea_rlig(glyph_subs_pairs):
	''' Generate a Required Ligatures OT Feature with given list of substitution tuples'''
	feature_dict = {'tag': 'rlig', 'com':'GSUB feature: Required Ligatures'}

	# - Build Feature code
	feature_body = []
	#glyph_subs_pairs = sort_pairs(glyph_subs_pairs, 1, 1)
	glyph_subs_pairs = sorted(glyph_subs_pairs, key=lambda i: (len(i[0].replace('underscore', '_')), i[0]))
		
	# - Process font's glyphs
	for subst_string, glyph_name in reversed(glyph_subs_pairs):
		feature_body.append(simple_sub.format(**{'glyph_in':subst_string, 'glyph_out':glyph_name}))

	# - Build feature body
	feature_dict['body'] = '\n'.join(feature_body)
	feature_code = simple_fea.format(**feature_dict)
		
	return feature_code

# - File related functions ---------------------------------------------
def output(i, message, print_output=True):
	msg_type = ['DONE', 'WARN', 'INFO', 'HELP', 'ERROR', 'ABORT']
	the_message = '{}:\t{}'.format(msg_type[i], message)
	if print_output: print(the_message, flush=True)
	return the_message

# - Run --------------------------------
time_run = datetime.datetime.now().strftime("%d.%m.%Y-%H:%M:%S")
time_start = time.time()

# -- Init and arguments ----------------
arg_parser = argparse.ArgumentParser(prog=tool_name,
									 description='{}. {}'.format(tool_description, tool_description_long),
									 formatter_class=argparse.RawDescriptionHelpFormatter)

arg_parser.add_argument('File',
						type=str,
						metavar='Designspace',
						help='Source UFO+Designspace file')

# -- Parse arguments
args = arg_parser.parse_args()

if not len(args.File) or not os.path.exists(args.File) or not os.path.isfile(args.File):
	output(-1, 'Invalid or missing UFO DesignSpace (*.designspace) file!')
	sys.exit(1)

# --- Get designspace file
designspace_file = args.File
path_ufo, file_designspace = os.path.split(designspace_file)

font = designspaceLib.DesignSpaceDocument()
font.read(designspace_file)

output(0,'Load: {};'.format(file_designspace))
output(3,'Inspector call: {};\t Font Object: {};'.format('inspect_obj(object)', 'font'))



	

